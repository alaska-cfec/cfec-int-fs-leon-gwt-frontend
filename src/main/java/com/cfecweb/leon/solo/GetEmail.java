package com.cfecweb.leon.solo;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import com.cfecweb.leon.config.HibernateSessionFactoryProvider;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

/*
 * The class takes a prepared CSV list of 2 year non renewals and generates
 * output of those CFECID's that have a valid email address in our database
 * for a given number of years. The source XLSX file is generated by our 2 yr
 * non-renewal program, then converted to a CSV.
 */
public class GetEmail {
	final SessionFactory fact = HibernateSessionFactoryProvider.getSessionFactory();
	Date sdate = null;
	
	@SuppressWarnings("rawtypes")
	public GetEmail() {
		Session sess = null;
		String fileLocation = "/home/mcmity/ADmounts/N/DP/mcmity/2yrnotices/";
		String fileName = "round1";
		String fileNew = fileName+"Email";
		String fileExt = ".csv";
		int csvNum = 0;
		int sqlNum = 0;
		List emailList = null;
		/*
		 *  if we ever wanted to make this a jar and pass parameters, the following
		 *  stringbuffer would be helpful in generating the in('x','y','x') sql command
		 */
		//StringBuffer years = new StringBuffer("");
		List<List<String>> records = new ArrayList<>();		
		try (BufferedReader br = new BufferedReader(new FileReader(fileLocation+fileName+fileExt))) {
		    String line;
		    while ((line = br.readLine()) != null) {
		        String[] values = line.split(":");
		        records.add(Arrays.asList(values));
		    }		    
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		int rsize = records.size()-1;
		Iterator<List<String>> csvIter = records.iterator();
		/*
		 *  Iterate 1 row due to header columns
		 */
		csvIter.next();
		try {
			sess = fact.openSession();
			while (csvIter.hasNext()) {
				csvIter.next();
				emailList = new ArrayList();
				/*
				 * The follow sql query generates a list of emails based on a CFECID and a number of years. 
				 * It orders by year descending, then takes the first record. This way, if someone didn't have
				 * an email for current year, we can still get their most recent given an acceptable span of time.
				 */
				emailList = sess.createNativeQuery("select email from tier2.arenew_entity where cfecid = '"+records.get(csvNum).get(0)+"' and ryear in('2021','2020', 2019) and email is not null order by ryear desc").list();
				if (emailList.size() > 0) {
					sqlNum = sqlNum + 1;
					System.out.println(records.get(csvNum).get(0) + " - " + records.get(csvNum).get(6) + " - " + records.get(csvNum).get(7) + " - " + emailList.get(0));
					// TODO send whatever data to the BulkEmail class which sends the email, then write back to the CSV file the email and date sent
				} else {
					/*
					 *  if there is no email, we can do something here if necessary
					 */
				}
				csvNum = csvNum + 1;
			}
			System.out.println("total record size is " + rsize);
			System.out.println("records with emails is " + sqlNum);
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			if (sess.isOpen()) {
				sess.flush();
				sess.close();
			}
		}
	}

	/*
	 * This main method can accept and pass parameters if we want to make this an executable JAR
	 * Was thinking the filename, beginning and ending years for email harvesting.
	 */
	@SuppressWarnings("unused")
	public static void main(String[] args) {
		GetEmail email = new GetEmail();
	}

}
